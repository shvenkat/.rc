#!/bin/sh

set -e -u -o pipefail


NAME="$(basename -- "$0")"
FRESH_URL="https://github.com/freshshell/fresh"
FRESH_CLONE="${HOME}/.fresh/source/freshshell/fresh"
FRESHRC="${HOME}/.freshrc"
CACHE_DIR="${HOME}/.cache/plugin_installer"
ZPLUG_CACHE_DIR="$CACHE_DIR/.zplug/repos"
ZPLUG_INSTALL_DIR="$HOME/.zplug/repos"

USAGE="USAGE: $NAME [-v|--verbose] [--freshrc <path>] [--install|--update]"
HELP="
SYNOPSIS

Installs dotfiles and updates plugins/packages. Dotfiles are installed using
fresh and as specified in ~/.freshrc [1]. If needed, fresh is installed and
~/.freshrc is created as a symlink. Add-on packages or plugins for certain
programs (currently zsh/zplug, neovim and emacs) are installed/updated (using a
build cache for speed).

$USAGE

    --freshrc <path>  Symlinks ~/.freshrc -> <path>. Required if ~/.freshrc does
                      not exist. <path> may be absolute or relative to ~ (HOME).
    --install         (Default) Installs dotfiles without pulling updates. Does
                      not install or update plugins/packages.
    --update          Fetches updates and installs dotfiles. Installs and
                      updates plugins/packages.
    -v|--verbose      Show informational messages during execution. Repeat to
                      see debug messages too.
    -h|--help         Show this help message.

NOTE FOR NEW USERS

With fresh, you can build your dotfiles by composition. For each dotfile, you
can concatenate files from various authors with your own, allowing you to build
on the work of others very easily. You can source files from any remote git
repository, and one local one (at ~/.dotfiles or FRESH_LOCAL) by writing a
simple freshrc file in a declarative style. Place your freshrc and custom
dotfiles (or dotfile portions) in ~/.dotfiles and push it to a suitable remote
for backup and synchronization. Avoid including in your repo, content you have
copied verbatim from elsewhere -- instead source it using fresh. You can then
use this script to build and install your dotfiles using fresh, and update
plugins/packages for common programs.

[1]: $FRESH_URL"


# ----------  functions  -----------------------------------------------------

# Format and print log messages.
#   $1: Log level: error, warn, info or debug.
#   $2 [$3 ...]: Log messages (will be concatenated with spaces in between).
log () {
    if [ -t 1 ]; then
        NORMAL="\\033[0m"
        BOLD="\\033[1m"
        RED="\\033[31m"
        YELLOW="\\033[33m"
    else
        NORMAL=""
        BOLD=""
        RED=""
        YELLOW=""
    fi
    level="$1"
    shift
    if [ "$level" = "error" ]; then
        echo " ${RED}E${NORMAL} ${BOLD}$*${NORMAL}" 1>&2
    elif [ "$level" = "warn" ]; then
        echo " ${YELLOW}W${NORMAL} ${BOLD}$*${NORMAL}" 1>&2
    elif [ "$level" = "info" ]; then
        if [ "$VERBOSITY" -gt 0 ]; then
            echo "   $*" 1>&2
        fi
    elif [ "$level" = "debug" ]; then
        if [ "$VERBOSITY" -gt 1 ]; then
            echo "   $*" 1>&2
        fi
    fi
}

# Run a command, logging its output. Errors are logged.
# Args:
#   $@: Command and arguments to be run.
run () {
    log debug "    $*"
    set +e
    output="$("$@" 2>&1)"
    retval=$?
    set -e
    echo "$output" | while IFS='' read -r line; do log debug "    $line"; done
    if [ "$retval" -ne 0 ]; then
        log error "Failed: $*"
        return 1
    fi
}

# Install fresh if needed. Fail if installation cannot be verified.
# Args: None.
install_fresh () {
    if [ ! -e "$FRESH_CLONE" ]; then
        log info "Cloning $FRESH_URL."
        run git clone "$FRESH_URL" "$FRESH_CLONE"
    elif [ -d "$FRESH_CLONE" ] && [ -z "$(find "$FRESH_CLONE" -mindepth 1 -print)" ]; then
        log info "Cloning $FRESH_URL."
        run git clone "$FRESH_URL" "$FRESH_CLONE"
    fi
    if [ ! -d "${FRESH_CLONE}/.git" ] || [ ! -x "$FRESH_CLONE/bin/fresh" ]; then
        log error "$FRESH_CLONE exists but does not appear to be clone of $FRESH_URL."
        exit 1
    fi
}

# Creates ~/.freshrc as a symlink if needed.
#   $1: Path to freshrc file. Empty string if not specified.
install_freshrc () {
    link="$FRESHRC"
    target="$1"
    # Create the freshrc symlink if needed.
    if [ -z "$target" ]; then
        if [ ! -e "$link" ]; then
            log error "$link does not exist, so --freshrc <path> is required."
            echo "$USAGE" 1>&2
            exit 2
        fi
    else
        if [ ! -e "$target" ]; then
            log error "freshrc file $target does not exist."
            exit 1
        fi
        if [ ! -e "$link" ] || [ -h "$link" ]; then
            log info "Creating symlink $link -> $target."
            run ln -sf "$target" "$link"
        else
            log error "$link already exists; cannot symlink it to $target."
            exit 1
        fi
    fi

    # Check that freshrc is readable.
    if [ ! -r "$link" ]; then
        log error "Cannot read freshrc file $link."
        exit 1
    fi

    # Warn if freshrc is not tracked in the git repo at ~/.dotfiles.
    if [ ! -h "$link" ]; then
        log warn "Consider placing ~/.freshrc in a git repo at \\~/.dotfiles" \
            "and using --freshrc to symlink it in ~."
    elif [ -h "$link" ]; then
        if [ -z "$target" ]; then
            target="$(readlink "$link")"
        fi
        relative_target="${target##$HOME/}"
        if [ "${relative_target##.dotfiles}" = "$relative_target" ]; then
            log warn "Consider placing ~/${relative_target} in a git repo" \
                "at \\~/.dotfiles and using --freshrc to symlink it in ~."
        fi
    fi
}

# Runs fresh to install dotfiles.
#   $1: fresh execution mode, either "install" or "update".
run_fresh () {
    mode="$1"
    log info "Running fresh to install dotfiles specified in $FRESHRC."
    run "$FRESH_CLONE/bin/fresh" "$mode"

    # Check time since last fresh update.
    if [ -z "$(find "$FRESH_CLONE/.git" -maxdepth 0 -mmin -$((60 * 24 * 90)) -print)" ];
    then
        log warn "Consider using --update next time to check for updates."
    fi
}

# Cache plugins for certain programs.
# Args: None.
cache_plugins () {
    if [ ! -e "$CACHE_DIR" ]; then
        mkdir -p "$CACHE_DIR"
    elif [ ! -d "$CACHE_DIR" ]; then
        log error "Cannot create $CACHE_DIR; conflicting file found."
        exit 1
    fi
    log info "Caching installed plugins."
    cache_zsh_zplug_plugins
}

# Restores plugins for certain programs from the cache.
# Args: None.
restore_plugins () {
    log info "Restoring cached plugins."
    restore_zsh_zplug_plugins
}

# Updates plugins for certain programs.
# Args: None.
update_plugins () {
    log info "Installing and/or updating plugins."
    update_zsh_zplug_plugins
    update_neovim_plugins
    update_emacs_plugins
}

# Caches zsh plugins managed by zplug.
# Args: None.
cache_zsh_zplug_plugins () {
    if ! which zsh >/dev/null 2>&1; then
        return
    fi
    if [ -d "$ZPLUG_INSTALL_DIR" ]; then
        log debug "Caching zsh plugins."
        mkdir -p "$ZPLUG_CACHE_DIR"
        rsync -a --delete "$ZPLUG_INSTALL_DIR/" "$ZPLUG_CACHE_DIR/"
    fi
}

# Restores cached zsh plugins managed by zplug.
# Args: None.
restore_zsh_zplug_plugins () {
    if ! which zsh >/dev/null 2>&1; then
        return
    fi
    if [ -d "$ZPLUG_CACHE_DIR" ] && [ ! -d "$ZPLUG_INSTALL_DIR" ]; then
        log debug "Restoring zsh/zplug plugins."
        mkdir -p "$ZPLUG_INSTALL_DIR"
        rsync -a --delete "$ZPLUG_CACHE_DIR/" "$ZPLUG_INSTALL_DIR/"
    fi
}

# Updates zsh plugins managed by zplug.
# Args: None.
update_zsh_zplug_plugins () {
    load_zplug="source $HOME/.zshrc"
    if ! which zsh >/dev/null 2>&1 \
           || ! zsh -c "$load_zplug && which zplug" >/dev/null 2>&1; then
        return
    fi
    log debug "Installing/updating zsh plugins."
    zplug="$load_zplug && zplug"
    zsh -c "$zplug check" || run zsh -c "$zplug install"
    run zsh -c "$zplug update"
    run zsh -c "$zplug clean"
    run zsh -c "$zplug clear"
}

# Updates neovim plugins managed by vim-plug.
update_neovim_plugins () {
    if ! which nvim >/dev/null 2>&1; then
        return
    fi
    # Plugins that use python need the neovim package.
    if which pip >/dev/null 2>&1; then
        # shellcheck disable=SC2143
        if [ -z "$(pip list 2>/dev/null | grep neovim 2>/dev/null)" ]; then
            log debug "Installing python package neovim."
            run pip install neovim
        fi
    elif which pip3 >/dev/null 2>&1; then
        # shellcheck disable=SC2143
        if [ -z "$(pip3 list 2>/dev/null | grep neovim 2>/dev/null)" ]; then
            log debug "Installing python package neovim."
            run pip3 install neovim
        fi
    fi
    log debug "Installing/updating neovim plugins."
    run nvim --headless +PlugUpgrade +PlugUpdate +PlugClean +qall
}

# Updates emacs plugins.
#   $1: Top-level plugin cache directory path.
update_emacs_plugins () {
    if ! which emacs >/dev/null 2>&1; then
        return
    fi
    log debug "Installing/updating emacs plugins."
    emacs -nw --kill
}


# ----------  main  ----------------------------------------------------------

# Parse arguments.
freshrc_path=""
fresh_mode=""
VERBOSITY=0
while [ $# -gt 0 ]; do
    case "$1" in
        --freshrc)
            if [ -n "$freshrc_path" ]; then
                echo "$USAGE" 1>&2
                exit 1
            fi
            if [ $# -lt 2 ]; then
                log error "Missing <path> argument following --freshrc."
                echo "$USAGE" 1>&2
                exit 1
            fi
            freshrc_path="$2"
            shift
            shift
            ;;
        --install|--update)
            if [ -n "$fresh_mode" ]; then
                echo "$USAGE" 1>&2
                exit 1
            fi
            fresh_mode="${1#--}"
            shift
            ;;
        -v|--verbose)
            VERBOSITY=$((VERBOSITY + 1))
            shift
            ;;
        -vv)
            VERBOSITY=$((VERBOSITY + 2))
            shift
            ;;
        -h|--help)
            echo "$HELP"
            exit 0
            ;;
        *)
            log error "Invalid argument $1." 1>&2
            echo "$USAGE" 1>&2
            exit 1
    esac
done
if [ -z "$fresh_mode" ]; then
    fresh_mode="install"
fi

install_fresh
install_freshrc "$freshrc_path"
cache_plugins
run_fresh "$fresh_mode"
restore_plugins
if [ "$fresh_mode" = "update" ]; then
    update_plugins
fi
